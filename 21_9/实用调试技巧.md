# 调试

Debug调试版本

Release发布版本

区别:

> Debug较Release更大
>
> Release会有自主优化,使程序在代码和速度上最优

F5与F9搭配使用

F5直接跳到断点处开始执行,F5启动调试

断点可以设置条件

F10逐过程,处理一个过程

F11逐语句,可以进入函数内部

CTRL + F5开始执行不调试

函数调用堆栈反馈函数的调用逻辑

栈=堆栈

看不懂代码时可以尝试调试看看代码执行逻辑

~~~
int main()
{
	int i = 0;
	int sum = 0;
	int ret = 1;
	int n = 0;
	scanf("%d", &n);
	int j = 0;
	for (j = 1; j <= n; j++)
	{
		ret = 1;	//清空ret很有必要
		for (i = 1; i <= j; i++)
		{
			ret *= i;
		}
		sum = sum + ret;
	}
	return 0;
}
//调试实操,找到ret没有清空的问题
~~~





~~~

int main()
{
	int i = 0;
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	for (i = 0; i <= 12; i++)
	{
		arr[i] = 0;
		printf("hehe\n");
	}
	return 0;
}
//为什么会死循环打印hehe呢
~~~

![image-20210928114339301](png/image-20210928114339301.png)

arr[12]和i用的是同一片空间,把arr[12]=0,i也变成了0

就死循环了

>1.i和arr是局部变量
>
>局部变量是放在栈区的
>
>栈区内存的使用习惯:
>
>先使用高地址空间,再使用低地址空间
>
>2.数组随着下标增长地址由低到高越界
>
>3.这里的栈是栈区 与数据结果的栈没关系

![image-20210928114704931](png/image-20210928114704931.png)

中间空了2格完全是巧合!

由编译器决定(出自<<c陷阱和缺陷>>)

>VC6.0h环境-0个整型
>
>gcc - 1个整型
>
>VS2013-2019- 2个整型

~~~
int main()
{
	
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int i = 0;
	for (i = 0; i <= 12; i++)
	{
		arr[i] = 0;
		printf("hehe\n");
	}
	return 0;
}
~~~

如果把i定义在arr下面,那么就不会再次碰到i,

数组越界报错

![image-20210928115125299](png/image-20210928115125299.png)

~~~
int main()
{
	
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int i = 0;
	for (i = 0; i <= 11; i++)
	{
		arr[i] = 0;
		printf("hehe\n");
	}
	return 0;
}
~~~

但改成i<=11时,也会数组越界报错

越界但没到死循环

如果一直死循环反而不会报错,程序还没有停止

# VS快捷键

Ctrl + K，Ctrl + D = 正确对齐所有代码

F12 = 转到定义

# 常见codeine技巧:

>尽量使用assert
>
>尽量使用const
>
>养成良好的编码习惯
>
>添加必要的注释
>
>避免编码的陷阱

~~~
void my_strcp(char* dest, char* src)
{
	while (*src!='\0')
	{
		*dest = *src;
		dest++;
		src++;
	}
	*dest = *src;

}
//模拟实现字符串拷贝strcp函数
int main()
{
	char arr1[20] = { "xxxxxx" };
	char arr2[] = "hello";
	my_strcp(arr1, arr2);
	printf("%s", arr1);
	return 0;
}
~~~

改进:

~~~

void my_strcp(char* dest, char* src)
{
	while (*src!='\0')
	{
		*dest++ = *src++;
		//反正是先使用再++
	}
	*dest = *src;

}
//模拟实现字符串拷贝strcp函数
int main()
{
	char arr1[20] = { "xxxxxx" };
	char arr2[] = "hello";
	my_strcp(arr1, arr2);
	printf("%s", arr1);
	return 0;
}
~~~

继续改进

~~~
void my_strcp(char* dest, char* src)
{
	while (*dest++ = *src++)
	{
		;
	//既拷贝了\0又能使循环停止
	//'\0'也就是数值0
	}

}
//模拟实现字符串拷贝strcp函数
int main()
{
	char arr1[20] = { "xxxxxx" };
	char arr2[] = "hello";
	my_strcp(arr1, arr2);
	printf("%s", arr1);
	return 0;
}
~~~

改进:

传进去空指针问题(空指针不能进行解引用操作的)

~~~
#include<assert.h>
void my_strcp(char* dest, char* src)
{
	assert(src != NULL);//断言
	assert(dest != NULL);//断言
	while (*dest++ = *src++)
	{
		;
	}
}
//模拟实现字符串拷贝strcp函数
int main()
{
	char arr1[20] = { "xxxxxx" };
	char arr2[] = "hello";
	my_strcp(arr1, NULL);
	printf("%s", arr1);
	return 0;
}
~~~

> Assertion failed: src != NULL, file ...

assert会把错误信息报出来

加上assert更容易发现问题,提高代码健壮性

~~~
#include<assert.h>
void my_strcp(char* dest, const char* src)
{
	assert(src != NULL);//断言
	assert(dest != NULL);//断言

	while (*src++ = *dest++)
	//左值不可修改!!!
	{
		;
	
	}

}
//模拟实现字符串拷贝strcp函数
int main()
{
	char arr1[20] = { "xxxxxx" };
	char arr2[] = "hello";
	my_strcp(arr1,arr2);
	printf("%s", arr1);
	return 0;
}
~~~

const char* src

这样如果dest src赋值赋反了,就根本无法编译

const修饰变量,这个变量就是常变量,不能被修改,但本质还是变量

~~~
int main()
{
	const int num = 10;
	int* p = &num;
	*p = 20;
	printf("%d\n", num);
	return 0;
}
~~~

本来不能直接修改num但通过地址间接修改了num的值

违背了const的原意

写成const char* src

就能维持dest指向的内容被修改,src指向的内容不该被修改的原意

~~~
int main()
{
	const int num = 10;
	const int* p = &num;
	*p = 20;
	printf("%d\n", num);
	return 0;
}
~~~

const修饰指针变量的时候

如果放在*的左边

修饰的是*p

表示指针指向的内容,不能通过指针来改变

即进门进不去,翻窗户也进不去了

~~~
int main()
{
	const int num = 10;
	const int* p = &num;
	//*p = 20;
	int n = 100;
	p = &n;
	printf("%d\n", num);
	return 0;
}
~~~

*p不能改,但是p本身可以改

~~~
int* const p=&num;
~~~

当const放在p的左边,修饰的是p

此时p就不能修改了

当*p可以修改

~~~
int const * const p=&a;

const int * const p=&a;
//这二者等价
但一般const放最前面,认为int*是一种类型
~~~

~~~
#include<assert.h>
char* my_strcp(char* dest, const char* src)
{
	assert(src != NULL);//断言
	assert(dest != NULL);//断言
	int ret = dest;
	while (*dest++ = *src++)
	{
		;
	
	}
	return ret;
}
//模拟实现字符串拷贝strcp函数
int main()
{
	char arr1[20] = { "xxxxxx" };
	char arr2[] = "hello";
	printf("%s", my_strcp(arr1,arr2););
	//链式访问
	return 0;
}
~~~

> strcpy库函数返回的是目标空间的首地址
>
> 故用char*类型接收



以后使用指针都要断言一下

可以是

~~~
assert(str!=NULL);
//或者
assert(str);
//空指针其实本质是0 0传进去就会触发断言,进而报错
~~~

~~~
#include<assert.h>
int my_strlen(const char* str)
{
	assert(str != NULL);
	int count = 0;
	while (*str++)
	{
		count++;
	}
	return count;
}
int main()
{
	char arr[] = "abcefggg";
	printf("%d\n", my_strlen(arr));
	return 0;
}
//目前看起来比较优秀的代码
~~~

__cdecl函数调用约定

![image-20210928141931981](png/image-20210928141931981.png)

c语言提供的参考代码

# 编程错误

## 编译型错误

看错误信息一般能看出来

## 链接型错误

无法解析的外部符号...

要么函数没定义

要么定义时名字写错了

## 运行时错误

一步步去调试找到错误

