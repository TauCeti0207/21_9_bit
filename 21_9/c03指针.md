# 指针定义

编号->地址

把地址形象称为指针

一个小的单元是1字节

指针是用来存放地址的，地址是唯一标示一块地址空间的

指针大小在32位平台是4个字节,64位平台8个字节

# 指针和指针类型

## 指针类型的意义



指针的类型

1决定了指针解引用的权限有多大

>字符型指针,char*解引用一次只能访问1个字节
>
>int* 指针解引用访问了4个字节

~~~
int main()
{
	int a = 0x11223344;
	int* pc = &a;
	char* pb = &a;
	return 0;
}
~~~

2决定了指针向前或者向后走一步有多大（距离）



~~~
int main()
{
	/*int a = 0x11223344;
	int* pc = &a;
	char* pb = &a;*/
	int arr[10] = { 0 };
	int* p = arr;
	char* p1 = arr;
	printf("%p\n", p);
	printf("%p\n", p+1);
	printf("%p\n", p1);
	printf("%p\n", p1+1);
	return 0;
}
~~~

打印结果:

>00B3F800
>00B3F804
>00B3F800
>00B3F801

~~~
int main()
{
	int arr[10] = { 0 };
	char* p = arr;
	int i = 0;
	for (i = 0; i < 10; i++)
	{
		*(p + i) = 1;
	}
	return 0;
}
~~~

![image-20210927104627765](png/image-20210927104627765.png)

操作的是一个字节的内容

整型指针+1,跳过4个字节,

字符指针+1,跳过一个字符

## 野指针

指针指向的位置不可知

>1指针未初始化

~~~
int main()
{
	//这里的p就是一个野指针
	int* p;
	//p是一个局部变量,局部变量不初始化默认是随机值
	*p = 20;//非法访问内存
	return 0;
}
~~~

>2指针越界

~~~
int main()
{
	int arr[10] = { 0 };
	int* p = arr;
	int i = 0;
	for (i = 0; i <= 10; i++)	//循环了11次,指针越界
	{
		*p = i;
		p++;
	}
	return 0;
}
~~~

>3指针指向的空间被释放

~~~
int* test()
{
	int a = 10;
	return &a;
}
int main()
{
	int* p = test();
	*p = 20;
	return 0;
}
~~~

a进入test时创建,出test时被销毁,还给了操作系统

此时*p=20就是非法访问内存了

~~~
int main()
{
	//当前不知道p应该初始化为什么地址时,直接初始化为NULL
	int* p = NULL;
	//但也有缺点
	*p=20;
	//引发了异常: 写入访问权限冲突。
	//0地址没有分配给用户,不能直接使用
	return 0;
}
~~~

> 要养成定义时初始化的好习惯
>
> c语言本身不会检查数组的越界行为
> 指针指向的空间被释放后即时去置空
> 指针使用之前检查有效性

~~~
	if (p != NULL)
	{
		*p = 10;
	}
	//检查有效性
~~~

## 指针的关系运算

~~~
int main()
{
	float values[5];
	float* vp;
	for (vp = &values[0]; vp < &values[5];)
	{
		*vp++ = 0;
		//先给*vp赋值了再++
	}
	return 0;
}
~~~

### 指针减指针

~~~
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("%d\n", &arr[9] - &arr[0]);
	return 0;
}
~~~

结果为:

9

>指针-指针得到的是2指针间的元素个数
>
>前提是2个指针指向同一块空间

~~~
int my_strlen(char* str)
{
	int count = 0;
	while (*str != 0)
	{
		count++;
		str++;
	}
	return count;
}
int main()//计数器的方法
{
	int len = my_strlen("abc");
	printf("%d\n", len);
	return 0;
}
~~~

"abc"传过去的也是首地址

类似于

~~~
int arr[]="abc";

int len = my_strlen(arr);
~~~

~~~
int my_strlen(char* str)
{
	char* start = str;
	while (*str != 0)
	{
		str++;
	}
	return str - start;
}
int main()	//z
{
	int len = my_strlen("abc");
	printf("%d\n", len);
	return 0;
}
~~~

### 指针关系运算

c标准规定:

>允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与
>
>指向第一个元素之前的那个内存位置的指针进行比较。

~~~
for(vp = &values[N_VALUES-1]; vp >= &values[0];vp--) {
    *vp = 0; 
}
//代码避免这样写
~~~

## 指针与数组

~~~
//arr[2]<==> *(arr+2)<==>*(p+2)<==>*(2+p)
//<==>*(2+arr) == 2[arr]
int main()
{
	int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	printf("%d\n", 2[arr]);
	printf("%d\n", arr[2]);
	return 0;
}
~~~

[]是一个操作符,2和arr是2个操作数

加法具有交换律

编译器会将arr[2]转换成*(arr+2)

### 指针数组

存放指针的数组

~~~
int* parr[5];
//存放整型指针的数组
~~~



## 二级指针

~~~
int main()
{
	int a = 10;
	int* pa = &a;
	int** ppa = &pa;
	//前面的*表示指向的是pa这个指针变量 pa的类型是int* 
	//后面的*表示ppa自身也是指针变量要加*
	return 0;
}
~~~

>*ppa==pa
>
>*pa==a
>
>**ppa==a

语法支持多级指针

